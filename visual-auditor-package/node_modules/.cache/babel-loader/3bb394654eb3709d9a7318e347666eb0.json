{"ast":null,"code":"import { ticks } from \"d3-array\";\nimport { format, formatSpecifier } from \"d3-format\";\nimport nice from \"./nice.js\";\nimport { copy, transformer } from \"./continuous.js\";\nimport { initRange } from \"./init.js\";\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10 : base === Math.E ? Math.exp : x => Math.pow(base, x);\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), x => Math.log(x) / base);\n}\n\nfunction reflect(f) {\n  return (x, k) => -f(-x, k);\n}\n\nexport function loggish(transform) {\n  const scale = transform(transformLog, transformExp);\n  const domain = scale.domain;\n  let base = 10;\n  let logs;\n  let pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n\n    return scale;\n  }\n\n  scale.base = function (_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function (_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = count => {\n    const d = domain();\n    let u = d[0];\n    let v = d[d.length - 1];\n    const r = v < u;\n    if (r) [u, v] = [v, u];\n    let i = logs(u);\n    let j = logs(v);\n    let k;\n    let t;\n    const n = count == null ? 10 : +count;\n    let z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.floor(i), j = Math.ceil(j);\n      if (u > 0) for (; i <= j; ++i) {\n        for (k = 1; k < base; ++k) {\n          t = i < 0 ? k / pows(-i) : k * pows(i);\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i <= j; ++i) {\n        for (k = base - 1; k >= 1; --k) {\n          t = i > 0 ? k / pows(-i) : k * pows(i);\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n      if (z.length * 2 < n) z = ticks(u, v, n);\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = (count, specifier) => {\n    if (count == null) count = 10;\n    if (specifier == null) specifier = base === 10 ? \"s\" : \",\";\n\n    if (typeof specifier !== \"function\") {\n      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;\n      specifier = format(specifier);\n    }\n\n    if (count === Infinity) return specifier;\n    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n\n    return d => {\n      let i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = () => {\n    return domain(nice(domain(), {\n      floor: x => pows(Math.floor(logs(x))),\n      ceil: x => pows(Math.ceil(logs(x)))\n    }));\n  };\n\n  return scale;\n}\nexport default function log() {\n  const scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = () => copy(scale, log()).base(scale.base());\n\n  initRange.apply(scale, arguments);\n  return scale;\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/Research/visual-auditor/visual-auditor-package/node_modules/d3-scale/src/log.js"],"names":["ticks","format","formatSpecifier","nice","copy","transformer","initRange","transformLog","x","Math","log","transformExp","exp","transformLogn","transformExpn","pow10","isFinite","powp","base","E","pow","logp","log10","log2","reflect","f","k","loggish","transform","scale","domain","logs","pows","rescale","_","arguments","length","count","d","u","v","r","i","j","t","n","z","floor","ceil","push","min","map","reverse","tickFormat","specifier","precision","trim","Infinity","max","round","apply"],"mappings":"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","sourcesContent":["import {ticks} from \"d3-array\";\nimport {format, formatSpecifier} from \"d3-format\";\nimport nice from \"./nice.js\";\nimport {copy, transformer} from \"./continuous.js\";\nimport {initRange} from \"./init.js\";\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : x => Math.pow(base, x);\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), x => Math.log(x) / base);\n}\n\nfunction reflect(f) {\n  return (x, k) => -f(-x, k);\n}\n\nexport function loggish(transform) {\n  const scale = transform(transformLog, transformExp);\n  const domain = scale.domain;\n  let base = 10;\n  let logs;\n  let pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = count => {\n    const d = domain();\n    let u = d[0];\n    let v = d[d.length - 1];\n    const r = v < u;\n\n    if (r) ([u, v] = [v, u]);\n\n    let i = logs(u);\n    let j = logs(v);\n    let k;\n    let t;\n    const n = count == null ? 10 : +count;\n    let z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.floor(i), j = Math.ceil(j);\n      if (u > 0) for (; i <= j; ++i) {\n        for (k = 1; k < base; ++k) {\n          t = i < 0 ? k / pows(-i) : k * pows(i);\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i <= j; ++i) {\n        for (k = base - 1; k >= 1; --k) {\n          t = i > 0 ? k / pows(-i) : k * pows(i);\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n      if (z.length * 2 < n) z = ticks(u, v, n);\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = (count, specifier) => {\n    if (count == null) count = 10;\n    if (specifier == null) specifier = base === 10 ? \"s\" : \",\";\n    if (typeof specifier !== \"function\") {\n      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;\n      specifier = format(specifier);\n    }\n    if (count === Infinity) return specifier;\n    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return d => {\n      let i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = () => {\n    return domain(nice(domain(), {\n      floor: x => pows(Math.floor(logs(x))),\n      ceil: x => pows(Math.ceil(logs(x)))\n    }));\n  };\n\n  return scale;\n}\n\nexport default function log() {\n  const scale = loggish(transformer()).domain([1, 10]);\n  scale.copy = () => copy(scale, log()).base(scale.base());\n  initRange.apply(scale, arguments);\n  return scale;\n}\n"]},"metadata":{},"sourceType":"module"}