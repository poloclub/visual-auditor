{"ast":null,"code":"import { Selection } from \"./index.js\";\nimport { EnterNode } from \"./enter.js\";\nimport constant from \"../constant.js\";\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length; // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Put any non-null nodes that don’t fit into exit.\n\n\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = new Map(),\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue; // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + \"\";\n\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  } // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n\n\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Add any remaining nodes that were not bound to data to exit.\n\n\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction datum(node) {\n  return node.__data__;\n}\n\nexport default function (value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n} // Given some data, this returns an array-like view of it: an object that\n// exposes a length property and allows numeric indexing. Note that unlike\n// selectAll, this isn’t worried about “live” collections because the resulting\n// array will only be used briefly while data is being bound. (It is possible to\n// cause the data to change while iterating by using a key function, but please\n// don’t; we’d rather avoid a gratuitous copy.)\n\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data ? data // Array, TypedArray, NodeList, array-like\n  : Array.from(data); // Map, Set, iterable, string, or anything else\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/visual-auditor/node_modules/d3-selection/src/selection/data.js"],"names":["Selection","EnterNode","constant","bindIndex","parent","group","enter","update","exit","data","i","node","groupLength","length","dataLength","__data__","bindKey","key","nodeByKeyValue","Map","keyValues","Array","keyValue","call","has","set","get","delete","datum","value","arguments","from","bind","parents","_parents","groups","_groups","m","j","arraylike","enterGroup","updateGroup","exitGroup","i0","i1","previous","next","_next","_enter","_exit"],"mappings":"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","sourcesContent":["import {Selection} from \"./index.js\";\nimport {EnterNode} from \"./enter.js\";\nimport constant from \"../constant.js\";\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = new Map,\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction datum(node) {\n  return node.__data__;\n}\n\nexport default function(value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n\n// Given some data, this returns an array-like view of it: an object that\n// exposes a length property and allows numeric indexing. Note that unlike\n// selectAll, this isn’t worried about “live” collections because the resulting\n// array will only be used briefly while data is being bound. (It is possible to\n// cause the data to change while iterating by using a key function, but please\n// don’t; we’d rather avoid a gratuitous copy.)\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data\n    ? data // Array, TypedArray, NodeList, array-like\n    : Array.from(data); // Map, Set, iterable, string, or anything else\n}\n"]},"metadata":{},"sourceType":"module"}