{"ast":null,"code":"import { Adder } from \"d3-array\";\nimport { asin, atan2, cos, degrees, epsilon, epsilon2, hypot, radians, sin, sqrt } from \"./math.js\";\nimport noop from \"./noop.js\";\nimport stream from \"./stream.js\";\nvar W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point\nx0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function polygonStart() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function polygonEnd() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n}; // Arithmetic mean of Cartesian vectors.\n\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\n\n\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = hypot(cx, cy, cz),\n      w = asin(m),\n      // line weight = angle\n  v = m && -w / m; // area weight multiplier\n\n  X2.add(v * cx);\n  Y2.add(v * cy);\n  Z2.add(v * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function (object) {\n  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream(object, centroidStream);\n  var x = +X2,\n      y = +Y2,\n      z = +Z2,\n      m = hypot(x, y, z); // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.\n\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = hypot(x, y, z); // If the feature still has an undefined ccentroid, then return.\n\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / m) * degrees];\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/visual-auditor/node_modules/d3-geo/src/centroid.js"],"names":["Adder","asin","atan2","cos","degrees","epsilon","epsilon2","hypot","radians","sin","sqrt","noop","stream","W0","W1","X0","Y0","Z0","X1","Y1","Z1","X2","Y2","Z2","lambda00","phi00","x0","y0","z0","centroidStream","sphere","point","centroidPoint","lineStart","centroidLineStart","lineEnd","centroidLineEnd","polygonStart","centroidRingStart","centroidRingEnd","polygonEnd","lambda","phi","cosPhi","centroidPointCartesian","x","y","z","centroidLinePointFirst","centroidLinePoint","w","centroidRingPointFirst","centroidRingPoint","cx","cy","cz","m","v","add","object","NaN"],"mappings":"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","sourcesContent":["import {Adder} from \"d3-array\";\nimport {asin, atan2, cos, degrees, epsilon, epsilon2, hypot, radians, sin, sqrt} from \"./math.js\";\nimport noop from \"./noop.js\";\nimport stream from \"./stream.js\";\n\nvar W0, W1,\n    X0, Y0, Z0,\n    X1, Y1, Z1,\n    X2, Y2, Z2,\n    lambda00, phi00, // first point\n    x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = hypot(cx, cy, cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2.add(v * cx);\n  Y2.add(v * cy);\n  Z2.add(v * cz);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 = 0;\n  X2 = new Adder();\n  Y2 = new Adder();\n  Z2 = new Adder();\n  stream(object, centroidStream);\n\n  var x = +X2,\n      y = +Y2,\n      z = +Z2,\n      m = hypot(x, y, z);\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = hypot(x, y, z);\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / m) * degrees];\n}\n"]},"metadata":{},"sourceType":"module"}