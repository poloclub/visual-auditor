{"ast":null,"code":"import ascending from \"./ascending.js\";\nimport { ascendingDefined, compareDefined } from \"./sort.js\";\nexport default function rank(values) {\n  var valueof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ascending;\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  var V = Array.from(values);\n  var R = new Float64Array(V.length);\n  if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;\n\n  var compareIndex = function compareIndex(i, j) {\n    return valueof(V[i], V[j]);\n  };\n\n  var k, r;\n  Uint32Array.from(V, function (_, i) {\n    return i;\n  }).sort(valueof === ascending ? function (i, j) {\n    return ascendingDefined(V[i], V[j]);\n  } : compareDefined(compareIndex)).forEach(function (j, i) {\n    var c = compareIndex(j, k === undefined ? j : k);\n\n    if (c >= 0) {\n      if (k === undefined || c > 0) k = j, r = i;\n      R[j] = r;\n    } else {\n      R[j] = NaN;\n    }\n  });\n  return R;\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/Research/visual-auditor/node_modules/d3-array/src/rank.js"],"names":["ascending","ascendingDefined","compareDefined","rank","values","valueof","Symbol","iterator","TypeError","V","Array","from","R","Float64Array","length","map","compareIndex","i","j","k","r","Uint32Array","_","sort","forEach","c","undefined","NaN"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,gBAAtB;AACA,SAAQC,gBAAR,EAA0BC,cAA1B,QAA+C,WAA/C;AAEA,eAAe,SAASC,IAAT,CAAcC,MAAd,EAA2C;AAAA,MAArBC,OAAqB,uEAAXL,SAAW;AACxD,MAAI,OAAOI,MAAM,CAACE,MAAM,CAACC,QAAR,CAAb,KAAmC,UAAvC,EAAmD,MAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;AACnD,MAAIC,CAAC,GAAGC,KAAK,CAACC,IAAN,CAAWP,MAAX,CAAR;AACA,MAAMQ,CAAC,GAAG,IAAIC,YAAJ,CAAiBJ,CAAC,CAACK,MAAnB,CAAV;AACA,MAAIT,OAAO,CAACS,MAAR,KAAmB,CAAvB,EAA0BL,CAAC,GAAGA,CAAC,CAACM,GAAF,CAAMV,OAAN,CAAJ,EAAoBA,OAAO,GAAGL,SAA9B;;AAC1B,MAAMgB,YAAY,GAAG,SAAfA,YAAe,CAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUb,OAAO,CAACI,CAAC,CAACQ,CAAD,CAAF,EAAOR,CAAC,CAACS,CAAD,CAAR,CAAjB;AAAA,GAArB;;AACA,MAAIC,CAAJ,EAAOC,CAAP;AACAC,EAAAA,WAAW,CACRV,IADH,CACQF,CADR,EACW,UAACa,CAAD,EAAIL,CAAJ;AAAA,WAAUA,CAAV;AAAA,GADX,EAEGM,IAFH,CAEQlB,OAAO,KAAKL,SAAZ,GAAwB,UAACiB,CAAD,EAAIC,CAAJ;AAAA,WAAUjB,gBAAgB,CAACQ,CAAC,CAACQ,CAAD,CAAF,EAAOR,CAAC,CAACS,CAAD,CAAR,CAA1B;AAAA,GAAxB,GAAiEhB,cAAc,CAACc,YAAD,CAFvF,EAGGQ,OAHH,CAGW,UAACN,CAAD,EAAID,CAAJ,EAAU;AACjB,QAAMQ,CAAC,GAAGT,YAAY,CAACE,CAAD,EAAIC,CAAC,KAAKO,SAAN,GAAkBR,CAAlB,GAAsBC,CAA1B,CAAtB;;AACA,QAAIM,CAAC,IAAI,CAAT,EAAY;AACV,UAAIN,CAAC,KAAKO,SAAN,IAAmBD,CAAC,GAAG,CAA3B,EAA8BN,CAAC,GAAGD,CAAJ,EAAOE,CAAC,GAAGH,CAAX;AAC9BL,MAAAA,CAAC,CAACM,CAAD,CAAD,GAAOE,CAAP;AACD,KAHD,MAGO;AACLR,MAAAA,CAAC,CAACM,CAAD,CAAD,GAAOS,GAAP;AACD;AACF,GAXH;AAYA,SAAOf,CAAP;AACD","sourcesContent":["import ascending from \"./ascending.js\";\nimport {ascendingDefined, compareDefined} from \"./sort.js\";\n\nexport default function rank(values, valueof = ascending) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  let V = Array.from(values);\n  const R = new Float64Array(V.length);\n  if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;\n  const compareIndex = (i, j) => valueof(V[i], V[j]);\n  let k, r;\n  Uint32Array\n    .from(V, (_, i) => i)\n    .sort(valueof === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex))\n    .forEach((j, i) => {\n      const c = compareIndex(j, k === undefined ? j : k);\n      if (c >= 0) {\n        if (k === undefined || c > 0) k = j, r = i;\n        R[j] = r;\n      } else {\n        R[j] = NaN;\n      }\n    });\n  return R;\n}\n"]},"metadata":{},"sourceType":"module"}