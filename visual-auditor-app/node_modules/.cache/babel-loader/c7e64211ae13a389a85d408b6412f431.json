{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/davidmunechika/Documents/Code/Research/visual-auditor/visual-auditor-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { max, tau } from \"./math.js\";\n\nfunction range(i, j) {\n  return Array.from({\n    length: j - i\n  }, function (_, k) {\n    return i + k;\n  });\n}\n\nfunction compareValue(compare) {\n  return function (a, b) {\n    return compare(a.source.value + a.target.value, b.source.value + b.target.value);\n  };\n}\n\nexport default function () {\n  return chord(false, false);\n}\nexport function chordTranspose() {\n  return chord(false, true);\n}\nexport function chordDirected() {\n  return chord(true, false);\n}\n\nfunction chord(directed, transpose) {\n  var padAngle = 0,\n      sortGroups = null,\n      sortSubgroups = null,\n      sortChords = null;\n\n  function chord(matrix) {\n    var n = matrix.length,\n        groupSums = new Array(n),\n        groupIndex = range(0, n),\n        chords = new Array(n * n),\n        groups = new Array(n),\n        k = 0,\n        dx;\n    matrix = Float64Array.from({\n      length: n * n\n    }, transpose ? function (_, i) {\n      return matrix[i % n][i / n | 0];\n    } : function (_, i) {\n      return matrix[i / n | 0][i % n];\n    }); // Compute the scaling factor from value to angle in [0, 2pi].\n\n    for (var i = 0; i < n; ++i) {\n      var x = 0;\n\n      for (var j = 0; j < n; ++j) {\n        x += matrix[i * n + j] + directed * matrix[j * n + i];\n      }\n\n      k += groupSums[i] = x;\n    }\n\n    k = max(0, tau - padAngle * n) / k;\n    dx = k ? padAngle : tau / n; // Compute the angles for each group and constituent chord.\n\n    {\n      var _x = 0;\n      if (sortGroups) groupIndex.sort(function (a, b) {\n        return sortGroups(groupSums[a], groupSums[b]);\n      });\n\n      var _iterator = _createForOfIteratorHelper(groupIndex),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var i = _step.value;\n          var x0 = _x;\n\n          if (directed) {\n            var subgroupIndex = range(~n + 1, n).filter(function (j) {\n              return j < 0 ? matrix[~j * n + i] : matrix[i * n + j];\n            });\n            if (sortSubgroups) subgroupIndex.sort(function (a, b) {\n              return sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]);\n            });\n\n            var _iterator2 = _createForOfIteratorHelper(subgroupIndex),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _j = _step2.value;\n\n                if (_j < 0) {\n                  var _chord = chords[~_j * n + i] || (chords[~_j * n + i] = {\n                    source: null,\n                    target: null\n                  });\n\n                  _chord.target = {\n                    index: i,\n                    startAngle: _x,\n                    endAngle: _x += matrix[~_j * n + i] * k,\n                    value: matrix[~_j * n + i]\n                  };\n                } else {\n                  var _chord2 = chords[i * n + _j] || (chords[i * n + _j] = {\n                    source: null,\n                    target: null\n                  });\n\n                  _chord2.source = {\n                    index: i,\n                    startAngle: _x,\n                    endAngle: _x += matrix[i * n + _j] * k,\n                    value: matrix[i * n + _j]\n                  };\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            groups[i] = {\n              index: i,\n              startAngle: x0,\n              endAngle: _x,\n              value: groupSums[i]\n            };\n          } else {\n            var _subgroupIndex = range(0, n).filter(function (j) {\n              return matrix[i * n + j] || matrix[j * n + i];\n            });\n\n            if (sortSubgroups) _subgroupIndex.sort(function (a, b) {\n              return sortSubgroups(matrix[i * n + a], matrix[i * n + b]);\n            });\n\n            var _iterator3 = _createForOfIteratorHelper(_subgroupIndex),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _j2 = _step3.value;\n\n                var _chord3 = void 0;\n\n                if (i < _j2) {\n                  _chord3 = chords[i * n + _j2] || (chords[i * n + _j2] = {\n                    source: null,\n                    target: null\n                  });\n                  _chord3.source = {\n                    index: i,\n                    startAngle: _x,\n                    endAngle: _x += matrix[i * n + _j2] * k,\n                    value: matrix[i * n + _j2]\n                  };\n                } else {\n                  _chord3 = chords[_j2 * n + i] || (chords[_j2 * n + i] = {\n                    source: null,\n                    target: null\n                  });\n                  _chord3.target = {\n                    index: i,\n                    startAngle: _x,\n                    endAngle: _x += matrix[i * n + _j2] * k,\n                    value: matrix[i * n + _j2]\n                  };\n                  if (i === _j2) _chord3.source = _chord3.target;\n                }\n\n                if (_chord3.source && _chord3.target && _chord3.source.value < _chord3.target.value) {\n                  var source = _chord3.source;\n                  _chord3.source = _chord3.target;\n                  _chord3.target = source;\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            groups[i] = {\n              index: i,\n              startAngle: x0,\n              endAngle: _x,\n              value: groupSums[i]\n            };\n          }\n\n          _x += dx;\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // Remove empty chords.\n\n    chords = Object.values(chords);\n    chords.groups = groups;\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n\n  chord.padAngle = function (_) {\n    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;\n  };\n\n  chord.sortGroups = function (_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n\n  chord.sortSubgroups = function (_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n\n  chord.sortChords = function (_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n\n  return chord;\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/Research/visual-auditor/visual-auditor-app/node_modules/d3-chord/src/chord.js"],"names":["max","tau","range","i","j","Array","from","length","_","k","compareValue","compare","a","b","source","value","target","chord","chordTranspose","chordDirected","directed","transpose","padAngle","sortGroups","sortSubgroups","sortChords","matrix","n","groupSums","groupIndex","chords","groups","dx","Float64Array","x","sort","x0","subgroupIndex","filter","index","startAngle","endAngle","Object","values","arguments"],"mappings":"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","sourcesContent":["import {max, tau} from \"./math.js\";\n\nfunction range(i, j) {\n  return Array.from({length: j - i}, (_, k) => i + k);\n}\n\nfunction compareValue(compare) {\n  return function(a, b) {\n    return compare(\n      a.source.value + a.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\n\nexport default function() {\n  return chord(false, false);\n}\n\nexport function chordTranspose() {\n  return chord(false, true);\n}\n\nexport function chordDirected() {\n  return chord(true, false);\n}\n\nfunction chord(directed, transpose) {\n  var padAngle = 0,\n      sortGroups = null,\n      sortSubgroups = null,\n      sortChords = null;\n\n  function chord(matrix) {\n    var n = matrix.length,\n        groupSums = new Array(n),\n        groupIndex = range(0, n),\n        chords = new Array(n * n),\n        groups = new Array(n),\n        k = 0, dx;\n\n    matrix = Float64Array.from({length: n * n}, transpose\n        ? (_, i) => matrix[i % n][i / n | 0]\n        : (_, i) => matrix[i / n | 0][i % n]);\n\n    // Compute the scaling factor from value to angle in [0, 2pi].\n    for (let i = 0; i < n; ++i) {\n      let x = 0;\n      for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];\n      k += groupSums[i] = x;\n    }\n    k = max(0, tau - padAngle * n) / k;\n    dx = k ? padAngle : tau / n;\n\n    // Compute the angles for each group and constituent chord.\n    {\n      let x = 0;\n      if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));\n      for (const i of groupIndex) {\n        const x0 = x;\n        if (directed) {\n          const subgroupIndex = range(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);\n          if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            if (j < 0) {\n              const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});\n              chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};\n            } else {\n              const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});\n              chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};\n            }\n          }\n          groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};\n        } else {\n          const subgroupIndex = range(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);\n          if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            let chord;\n            if (i < j) {\n              chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});\n              chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};\n            } else {\n              chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});\n              chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};\n              if (i === j) chord.source = chord.target;\n            }\n            if (chord.source && chord.target && chord.source.value < chord.target.value) {\n              const source = chord.source;\n              chord.source = chord.target;\n              chord.target = source;\n            }\n          }\n          groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};\n        }\n        x += dx;\n      }\n    }\n\n    // Remove empty chords.\n    chords = Object.values(chords);\n    chords.groups = groups;\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n\n  chord.padAngle = function(_) {\n    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;\n  };\n\n  chord.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n\n  chord.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n\n  chord.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n\n  return chord;\n}\n"]},"metadata":{},"sourceType":"module"}