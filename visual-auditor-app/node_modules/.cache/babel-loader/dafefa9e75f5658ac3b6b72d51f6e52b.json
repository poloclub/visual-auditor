{"ast":null,"code":"import { tickIncrement } from \"./ticks.js\";\nexport default function nice(start, stop, count) {\n  var prestep;\n\n  while (true) {\n    var step = tickIncrement(start, stop, count);\n\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start, stop];\n    } else if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n\n    prestep = step;\n  }\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/Research/visual-auditor/visual-auditor-app/node_modules/d3-array/src/nice.js"],"names":["tickIncrement","nice","start","stop","count","prestep","step","isFinite","Math","floor","ceil"],"mappings":"AAAA,SAAQA,aAAR,QAA4B,YAA5B;AAEA,eAAe,SAASC,IAAT,CAAcC,KAAd,EAAqBC,IAArB,EAA2BC,KAA3B,EAAkC;AAC/C,MAAIC,OAAJ;;AACA,SAAO,IAAP,EAAa;AACX,QAAMC,IAAI,GAAGN,aAAa,CAACE,KAAD,EAAQC,IAAR,EAAcC,KAAd,CAA1B;;AACA,QAAIE,IAAI,KAAKD,OAAT,IAAoBC,IAAI,KAAK,CAA7B,IAAkC,CAACC,QAAQ,CAACD,IAAD,CAA/C,EAAuD;AACrD,aAAO,CAACJ,KAAD,EAAQC,IAAR,CAAP;AACD,KAFD,MAEO,IAAIG,IAAI,GAAG,CAAX,EAAc;AACnBJ,MAAAA,KAAK,GAAGM,IAAI,CAACC,KAAL,CAAWP,KAAK,GAAGI,IAAnB,IAA2BA,IAAnC;AACAH,MAAAA,IAAI,GAAGK,IAAI,CAACE,IAAL,CAAUP,IAAI,GAAGG,IAAjB,IAAyBA,IAAhC;AACD,KAHM,MAGA,IAAIA,IAAI,GAAG,CAAX,EAAc;AACnBJ,MAAAA,KAAK,GAAGM,IAAI,CAACE,IAAL,CAAUR,KAAK,GAAGI,IAAlB,IAA0BA,IAAlC;AACAH,MAAAA,IAAI,GAAGK,IAAI,CAACC,KAAL,CAAWN,IAAI,GAAGG,IAAlB,IAA0BA,IAAjC;AACD;;AACDD,IAAAA,OAAO,GAAGC,IAAV;AACD;AACF","sourcesContent":["import {tickIncrement} from \"./ticks.js\";\n\nexport default function nice(start, stop, count) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start, stop, count);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start, stop];\n    } else if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}