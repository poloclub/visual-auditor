{"ast":null,"code":"import { Adder } from \"d3-array\";\nimport { areaStream, areaRingSum } from \"./area.js\";\nimport { cartesian, cartesianCross, cartesianNormalizeInPlace, spherical } from \"./cartesian.js\";\nimport { abs, degrees, epsilon, radians } from \"./math.js\";\nimport stream from \"./stream.js\";\nvar lambda0, phi0, lambda1, phi1, // bounds\nlambda2, // previous lambda-coordinate\nlambda00, phi00, // first point\np0, // previous 3D point\ndeltaSum, ranges, range;\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function () {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function () {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon) phi1 = 90;else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function () {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n} // Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\n\n\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function (feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream); // First, sort ranges by their minimum longitudes.\n\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.\n\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    } // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n\n\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];\n}","map":{"version":3,"sources":["/Users/davidmunechika/Documents/Code/Research/visual-auditor/visual-auditor-app/node_modules/d3-geo/src/bounds.js"],"names":["Adder","areaStream","areaRingSum","cartesian","cartesianCross","cartesianNormalizeInPlace","spherical","abs","degrees","epsilon","radians","stream","lambda0","phi0","lambda1","phi1","lambda2","lambda00","phi00","p0","deltaSum","ranges","range","boundsStream","point","boundsPoint","lineStart","boundsLineStart","lineEnd","boundsLineEnd","polygonStart","boundsRingPoint","boundsRingStart","boundsRingEnd","polygonEnd","sphere","lambda","phi","push","linePoint","p","normal","equatorial","inflection","delta","sign","lambdai","phii","antimeridian","angle","add","rangeCompare","a","b","rangeContains","x","feature","i","n","merged","deltaMax","Infinity","length","sort","NaN"],"mappings":"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","sourcesContent":["import {Adder} from \"d3-array\";\nimport {areaStream, areaRingSum} from \"./area.js\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian.js\";\nimport {abs, degrees, epsilon, radians} from \"./math.js\";\nimport stream from \"./stream.js\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum,\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum = new Adder();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  },\n  sphere: function() {\n    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n"]},"metadata":{},"sourceType":"module"}